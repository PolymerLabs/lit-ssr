/**
 * @license
 * Copyright (c) 2019 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */

import { TemplateResult } from 'lit-html';
import {marker} from 'lit-html/lib/template.js';
import { Writable } from 'stream';

// types only
import {Node, DefaultTreeDocumentFragment, DefaultTreeNode} from 'parse5';

import { depthFirst, parseFragment, isCommentNode, isElement, getAttr } from './parse5-utils.js';

const templateCache = new Map<TemplateStringsArray, {html: string, ast: DefaultTreeDocumentFragment}>();

const getTemplate = (result: TemplateResult) => {
  const template = templateCache.get(result.strings);
  if (template !== undefined) {
    return template;
  }
  const html = result.getHTML();
  const ast = parseFragment(html, {
    sourceCodeLocationInfo: true,
  }) as DefaultTreeDocumentFragment;
  templateCache.set(result.strings, {html, ast});
  return {html, ast};
};

type ChildInfo = {
  nodes: DefaultTreeNode[];
  html: string;
};

export const renderToStream = (result: TemplateResult, stream: Writable, claimedNodes: Set<Node> = new Set(), children?: ChildInfo) => {
  // In order to render a TemplateResult we have to handle and stream out
  // different parts of the result separately:
  //   - Literal sections of the template
  //   - Defined custom element within the literal sections
  //   - Values in the result
  //
  // This means we can't just iterate through the tempalte literals and values,
  // we must parse and traverse the template's HTML. but we don't want to pay
  // the cost of serializing the HTML node-by-node when we already have the
  // template in string form. So we parse with location infor turned on and use
  // that to index into the HTML string generated by TemplateResult.getHTML().
  // During the tree walk we will handle expression marker nodes and custom
  // elements. For each we will record the offset of the node, and output the
  // previous span of HTML.

  const {html, ast} = getTemplate(result);

  let partIndex = 0;
  let lastOffset = 0;

  stream.write(`<!--lit-part ${result.digest}-->`);
  for (const node of depthFirst(ast)) {
    if (isCommentNode(node)) {
      if (node.data === marker) {

        const offset = node.sourceCodeLocation!.startOffset;
        stream.write(html.substring(lastOffset, offset));
        lastOffset = node.sourceCodeLocation!.endOffset;

        const value = result.values[partIndex];
        if (value instanceof TemplateResult) {
          renderToStream(value, stream, claimedNodes, children);
        } else {
          stream.write(`<!--lit-part-->`);
          if (value === undefined || value === null) {
            // do nothing
          } else {
            // TODO: convert value to string, handle arrays, etc.
            stream.write(value);
          }
          stream.write(`<!--/lit-part-->`);
        }    
        partIndex++;
      }
    } else if (isElement(node)) {
      if (claimedNodes.has(node)) {
        // Skip the already distributed node
        const startOffset = node.sourceCodeLocation!.startOffset;
        const endOffset = node.sourceCodeLocation!.endOffset;
        stream.write(html.substring(lastOffset, startOffset));
        lastOffset = endOffset;

        // TODO: write the distributed node placeholder comment
      }
      const tagName = node.tagName;
      if (tagName === 'slot') {
        const slotName = getAttr(node, 'name');
        if (children === undefined || children.nodes.length === 0) {
          // render nothing? We need to get the distributed children here...
          const endTagEndOffset = node.sourceCodeLocation!.endTag.endOffset;
          lastOffset = endTagEndOffset;
        } else {
          for (const child of children.nodes) {
            // All these children are from the same template
            // While rendering nested templates, we may create children from
            // other templates, so we can't render them by slicing the current
            // html string. We'll have to evaluate the sub templates and stream
            // them here...
            if (isCommentNode(node) && (node.data === marker)) {
              // TODO: render sub-template, pull in slotted chlidren here
            } else {
              // TODO: named slots
              if (slotName === undefined) {
                const startOffset = (child as any).sourceCodeLocation!.startOffset;
                const endOffset = (child as any).sourceCodeLocation!.endOffset;
                stream.write(children.html.substring(startOffset, endOffset));
                claimedNodes.add(child);
                // TODO: add an attribute for the placeholder comment id
              }
            }
          }
        }
        lastOffset = node.sourceCodeLocation!.endOffset;
      } else if (tagName.indexOf('-') !== -1) {
        const ctor = customElements.get(tagName);
        if (ctor !== undefined) {
          // Write the start tag
          const startTagEndOffset = node.sourceCodeLocation!.startTag.endOffset;
          stream.write(html.substring(lastOffset, startTagEndOffset));
          lastOffset = startTagEndOffset;

          // Instantiate the element and stream its render() result
          const instance = new ctor();
          renderToStream(instance.render(), stream, claimedNodes, {nodes: node.childNodes, html});

          // This turned out to be unneccessary in one case, maybe all?
          // // Write the end tag
          // const endTagEndOffset = node.sourceCodeLocation!.endTag.endOffset;
          // stream.write(html.substring(lastOffset, endTagEndOffset));
          // lastOffset = endTagEndOffset;
        }
      }
    }
  }
  stream.write(html.substring(lastOffset));
  stream.write(`<!--/lit-part-->`);
  console.assert(partIndex === result.values.length);
};
