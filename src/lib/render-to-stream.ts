/**
 * @license
 * Copyright (c) 2019 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */

import { TemplateResult } from 'lit-html';
import {marker} from 'lit-html/lib/template.js';
import { Writable } from 'stream';

import { depthFirst, parseFragment } from './parse5-utils.js';

const templateCache = new Map<TemplateStringsArray, {html: string, ast: any}>();

const getTemplate = (result: TemplateResult) => {
  const template = templateCache.get(result.strings);
  if (template !== undefined) {
    return template;
  }
  const html = result.getHTML();
  const ast = parseFragment(html, {
    sourceCodeLocationInfo: true,
  });
  templateCache.set(result.strings, {html, ast});
  return {html, ast};
};

export const renderToStream = (result: TemplateResult, stream: Writable) => {
  // In order to render a TemplateResult we have to handle and stream out
  // different parts of the result separately:
  //   - Literal sections of the template
  //   - Defined custom element within the literal sections
  //   - Values in the result
  //
  // This means we can't just iterate through the tempalte literals and values,
  // we must parse and traverse the template's HTML. but we don't want to pay
  // the cost of serializing the HTML node-by-node when we already have the
  // template in string form. So we parse with location infor turned on and use
  // that to index into the HTML string generated by TemplateResult.getHTML().
  // During the tree walk we will handle expression marker nodes and custom
  // elements. For each we will record the offset of the node, and output the
  // previous span of HTML.

  const {html, ast} = getTemplate(result);

  let partIndex = 0;
  let lastOffset = 0;

  stream.write(`<!--lit-part ${result.digest}-->`);
  for (const node of depthFirst(ast)) {
    if (node.nodeName === '#comment') {
      if (node.data === marker) {

        const offset = node.sourceCodeLocation.startOffset;
        stream.write(html.substring(lastOffset, offset));
        lastOffset = node.sourceCodeLocation.endOffset;

        const value = result.values[partIndex];
        if (value instanceof TemplateResult) {
          renderToStream(value, stream);
        } else {
          stream.write(`<!--lit-part-->`);
          stream.write(value);
          stream.write(`<!--/lit-part-->`);
        }    
        partIndex++;
      }
    } else if (node.tagName !== undefined && node.tagName.indexOf('-') !== -1) {
      const ctor = customElements.get(node.tagName);
      if (ctor !== undefined) {
        // Write the start tag
        const startTagEndOffset = node.sourceCodeLocation.startTag.endOffset;
        stream.write(html.substring(lastOffset, startTagEndOffset));
        lastOffset = startTagEndOffset;

        // Instantiate the element and stream its render() result
        const element = new ctor();
        renderToStream(element.render(), stream);

        // Write the end tag
        const endTagEndOffset = node.sourceCodeLocation.endTag.endOffset;
        stream.write(html.substring(lastOffset, endTagEndOffset));
        lastOffset = endTagEndOffset;
      }
    }
  }
  stream.write(html.substring(lastOffset));
  stream.write(`<!--/lit-part-->`);
  console.assert(partIndex === result.values.length);
};
