/**
 * @license
 * Copyright (c) 2019 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */

import { TemplateResult } from 'lit-html';
import {marker} from 'lit-html/lib/template.js';
import { Writable } from 'stream';

// types only
import {Node, DefaultTreeDocumentFragment, DefaultTreeNode} from 'parse5';

import { depthFirst, parseFragment, isCommentNode, isElement, getAttr, isTextNode } from './parse5-utils.js';

const templateCache = new Map<TemplateStringsArray, {html: string, ast: DefaultTreeDocumentFragment}>();

const getTemplate = (result: TemplateResult) => {
  const template = templateCache.get(result.strings);
  if (template !== undefined) {
    return template;
  }
  const html = result.getHTML();
  const ast = parseFragment(html, {
    sourceCodeLocationInfo: true,
  }) as DefaultTreeDocumentFragment;
  templateCache.set(result.strings, {html, ast});
  return {html, ast};
};

// Idea: make this a class that's responsible for rendering a template value - a
// specific TemplateResult *reference*. Passing an instance of this class down
// will allow distribution slots to defer rendering and communicate what's been
// distributed so that when this instance continues to render it already knows
// what to skip. Fold claimedNodes into here.
type ChildInfo = {
  nodes: DefaultTreeNode[];
  html: string;
  result: TemplateResult;
  partIndex: number;
};
type SlotInfo = {
  slotName: string;
};
type RenderInfo = {
  children?: ChildInfo;
  slot?: SlotInfo;
}

export const renderNodePartToStream = (value: unknown, stream: Writable, claimedNodes: Set<Node> = new Set(), renderInfo: RenderInfo) => {
  if (value instanceof TemplateResult) {
    stream.write(`<!--lit-part ${value.digest}-->`);
    renderToStream(value, stream, claimedNodes, renderInfo);
  } else {
    stream.write(`<!--lit-part-->`);
    if (value === undefined || value === null) {
      // do nothing
    } else {
      // TODO: convert value to string, handle arrays, directives, etc.
      stream.write(String(value));
    }
  }
  stream.write(`<!--/lit-part-->`);
}

export const renderToStream = (result: TemplateResult, stream: Writable, claimedNodes: Set<Node> = new Set(), renderInfo: RenderInfo = {}) => {
  const {slot} = renderInfo;
  let childPartIndex: number|undefined;
  // In order to render a TemplateResult we have to handle and stream out
  // different parts of the result separately:
  //   - Literal sections of the template
  //   - Defined custom element within the literal sections
  //   - Values in the result
  //
  // This means we can't just iterate through the tempalte literals and values,
  // we must parse and traverse the template's HTML. but we don't want to pay
  // the cost of serializing the HTML node-by-node when we already have the
  // template in string form. So we parse with location infor turned on and use
  // that to index into the HTML string generated by TemplateResult.getHTML().
  // During the tree walk we will handle expression marker nodes and custom
  // elements. For each we will record the offset of the node, and output the
  // previous span of HTML.

  const {html, ast} = getTemplate(result);

  /* The next value in result.values to render */
  let partIndex = 0;

  /* The index of the last distributed value to be rendered to a slot */
  let distributedIndex = -1;

  /* The last offset of html written to the stream */
  let lastOffset: number|undefined = 0;

  const flushTo = (offset?: number) => {
    if (lastOffset === undefined) {
      throw new Error('lastOffset is undefined');
    }
    stream.write(html.substring(lastOffset, offset));
    lastOffset = offset;
  };

  const skipTo = (offset: number) => {
    lastOffset = offset;
  };

  const handleNode = (node: DefaultTreeNode) => {
    console.log('handleNode', node.nodeName);
    if (isCommentNode(node)) {
      if (node.data === marker) {
        flushTo(node.sourceCodeLocation!.startOffset);
        skipTo(node.sourceCodeLocation!.endOffset);
        const value = result.values[partIndex++];
        console.log('expression marker', value);
        console.log(partIndex, distributedIndex, partIndex <= distributedIndex)

        if (partIndex <= distributedIndex) {
          // This means we've already consumed this part during distribution
          // into a slot, so we don't want to render the value, but we do want
          // to render the part markers for subsequent hydration.
          // TODO: we also want to render placeholder comments for the
          // distributed nodes
          if (value instanceof TemplateResult) {
            stream.write(`<!--lit-part ${value.digest}--><!--/lit-part-->`);
          } else {
            stream.write(`<!--lit-part--><!--/lit-part-->`);
          }
        } else {
          renderNodePartToStream(value, stream, claimedNodes, renderInfo);
        }
      }
    } else if (isElement(node)) {
      if (claimedNodes.has(node)) {
        // Skip the already distributed node
        flushTo(node.sourceCodeLocation!.startOffset);
        skipTo(node.sourceCodeLocation!.endOffset);
        // [1] TODO: write the distributed node placeholder comment
      } else {
        const tagName = node.tagName;
        for (const attr of node.attrs) {
          if (attr.name.endsWith('$lit$')) {
            const attrSourceLocation = node.sourceCodeLocation!.attrs[attr.name];
            const attrNameStartOffset = attrSourceLocation.startOffset;
            const attrEndOffset = attrSourceLocation.endOffset;
            const value = result.values[partIndex++];

            stream.write(html.substring(lastOffset!, attrNameStartOffset));
            stream.write(attr.name.substring(0, attr.name.length - 5));
            stream.write('="');
            stream.write(value);
            stream.write('"');
            lastOffset = attrEndOffset;

            // TODO: render marker comment for attribute binding
          }
        }
        if (tagName === 'slot') {
          flushTo(node.sourceCodeLocation!.startTag.startOffset);
          const slotName = getAttr(node, 'name');
          console.log('slot', slotName);
          if (renderInfo.children === undefined || renderInfo.children.nodes.length === 0) {
            // render nothing? We need to get the distributed children here...
            const endTagEndOffset = node.sourceCodeLocation!.endTag.endOffset;
            lastOffset = endTagEndOffset;
          } else {
            console.log('in slot');
            childPartIndex = renderInfo.children.partIndex;
            for (const child of renderInfo.children.nodes) {
              // All these children are from the same template
              // While rendering nested templates, we may create children from
              // other templates, so we can't render them by slicing the current
              // html string. We'll have to evaluate the sub templates and stream
              // them here...
              // console.log('child', child.nodeName);
              if (isCommentNode(child) && (child.data === marker)) {
                // TODO: render sub-template, pull in slotted chlidren here
                // console.log('dynamic child');
                // What do we need to do to render children from another templates?
                //  - increment the partIndex from where the child marker node came from
                //  - get the TemplateResult value
                //  - render the template
                //  - iterate through the rendered result...
                console.log({slotName, childPartIndex});
                const childValue = renderInfo.children.result.values[childPartIndex++];
                // TODO: this renders the child value in this slot, but we need
                // to render the part marker at the original location at [1]
                if (childValue instanceof TemplateResult) {
                  console.log('A');
                  renderToStream(childValue, stream, claimedNodes, {slot: {slotName}});
                } else {
                  if (childValue === null || childValue === undefined) {
                    // do nothing
                  } else {
                    stream.write(String(childValue));
                  }
                }
              } else {
                const childSlotName = getAttr(child, 'slot');
                if (slotName === childSlotName) {
                  const startOffset = (child as any).sourceCodeLocation!.startOffset;
                  const endOffset = (child as any).sourceCodeLocation!.endOffset;
                  stream.write(renderInfo.children.html.substring(startOffset, endOffset));
                  claimedNodes.add(child);
                  // TODO: add an attribute for the placeholder comment id
                }
              }
            }
            // renderInfo.children.partIndex = childPartIndex;
          }
          lastOffset = node.sourceCodeLocation!.endOffset;
        } else if (tagName.indexOf('-') !== -1) {
          const ctor = customElements.get(tagName);
          if (ctor !== undefined) {
            // Write the start tag
            flushTo(node.sourceCodeLocation!.startTag.endOffset);

            // Instantiate the element and stream its render() result
            // TODO: try/catch
            const instance = new ctor();
            const childInfo = {
              nodes: node.childNodes,
              html,
              result,
              partIndex};
            renderNodePartToStream(instance.render(), stream, claimedNodes, {children: childInfo});
            // distributedIndex = childInfo.partIndex;
            distributedIndex = childInfo.partIndex;
          }
        }
      }
    }
  }

  // At the top-level of a TemplateResult we may have nodes that are children of
  // an element with slots, so we need to handle top-level nodes specially in an
  // outer loop. From there we perform a depth-first traversal.
  if (ast.childNodes === undefined) {
    return;
  }
  console.log('renderToStream', slot !== undefined, slot && slot.slotName);
  for (const node of ast.childNodes) {
    if (slot !== undefined) {
      if (isElement(node)) {
        const nodeSlotName = getAttr(node, 'slot');
        console.log('slotting element', node.nodeName, nodeSlotName, nodeSlotName === slot.slotName);
        if (nodeSlotName === slot.slotName) {
          skipTo(node.sourceCodeLocation!.startOffset);
          for (const child of depthFirst(node)) {
            handleNode(child);
          }
          flushTo(node.sourceCodeLocation!.endOffset);
          // claimedNodes.add(node);
        } else {
          skipTo(node.sourceCodeLocation!.endOffset);
        }
      } else if (slot.slotName === undefined && isTextNode(node)) {
        for (const child of depthFirst(node)) {
          handleNode(child);
        }
      }
    } else {
      for (const child of depthFirst(node)) {
        handleNode(child);
      }
    }
  }
  if (renderInfo.children !== undefined && childPartIndex !== undefined) {
    renderInfo.children.partIndex = childPartIndex;
  }

  flushTo();
  if (partIndex !== result.values.length) {
    throw new Error(`unexpected final partIndex: ${partIndex} !== ${result.values.length}`);
  }
};
